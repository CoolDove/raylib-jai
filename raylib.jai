//
// AUTOGENERATED
//

LIGHTGRAY :: Color.{  200, 200, 200, 255  };
GRAY :: Color.{  130, 130, 130, 255  };
DARKGRAY :: Color.{  80, 80, 80, 255  };
YELLOW :: Color.{  253, 249, 0, 255  };
GOLD :: Color.{  255, 203, 0, 255  };
ORANGE :: Color.{  255, 161, 0, 255  };
PINK :: Color.{  255, 109, 194, 255  };
RED :: Color.{  230, 41, 55, 255  };
MAROON :: Color.{  190, 33, 55, 255  };
GREEN :: Color.{  0, 228, 48, 255  };
LIME :: Color.{  0, 158, 47, 255  };
DARKGREEN :: Color.{  0, 117, 44, 255  };
SKYBLUE :: Color.{  102, 191, 255, 255  };
BLUE :: Color.{  0, 121, 241, 255  };
DARKBLUE :: Color.{  0, 82, 172, 255  };
PURPLE :: Color.{  200, 122, 255, 255  };
VIOLET :: Color.{  135, 60, 190, 255  };
DARKPURPLE :: Color.{  112, 31, 126, 255  };
BEIGE :: Color.{  211, 176, 131, 255  };
BROWN :: Color.{  127, 106, 79, 255  };
DARKBROWN :: Color.{  76, 63, 47, 255  };
WHITE :: Color.{  255, 255, 255, 255  };
BLACK :: Color.{  0, 0, 0, 255  };
BLANK :: Color.{  0, 0, 0, 0  };
MAGENTA :: Color.{  255, 0, 255, 255  };
RAYWHITE :: Color.{  245, 245, 245, 255  };

TraceLogCallback :: #type (logType: s32, text: *u8, args: ..*u8);

ConfigFlag :: enum_flags {
    FLAG_RESERVED           :: 1;    // Reserved
    FLAG_FULLSCREEN_MODE    :: 2;    // Set to run program in fullscreen
    FLAG_WINDOW_RESIZABLE   :: 4;    // Set to allow resizable window
    FLAG_WINDOW_UNDECORATED :: 8;    // Set to disable window decoration (frame and buttons)
    FLAG_WINDOW_TRANSPARENT :: 16;   // Set to allow transparent window
    FLAG_WINDOW_HIDDEN      :: 128;  // Set to create the window initially hidden
    FLAG_WINDOW_ALWAYS_RUN  :: 256;  // Set to allow windows running while minimized
    FLAG_MSAA_4X_HINT       :: 32;   // Set to try enabling MSAA 4X
    FLAG_VSYNC_HINT         :: 64;
}

TraceLogType :: enum {
    LOG_ALL :: 0;        // Display all logs
    LOG_TRACE;
    LOG_DEBUG;
    LOG_INFO;
    LOG_WARNING;
    LOG_ERROR;
    LOG_FATAL;
    LOG_NONE;
}

KeyboardKey :: enum {
    // Alphanumeric keys
    KEY_APOSTROPHE      :: 39;
    KEY_COMMA           :: 44;
    KEY_MINUS           :: 45;
    KEY_PERIOD          :: 46;
    KEY_SLASH           :: 47;
    KEY_ZERO            :: 48;
    KEY_ONE             :: 49;
    KEY_TWO             :: 50;
    KEY_THREE           :: 51;
    KEY_FOUR            :: 52;
    KEY_FIVE            :: 53;
    KEY_SIX             :: 54;
    KEY_SEVEN           :: 55;
    KEY_EIGHT           :: 56;
    KEY_NINE            :: 57;
    KEY_SEMICOLON       :: 59;
    KEY_EQUAL           :: 61;
    KEY_A               :: 65;
    KEY_B               :: 66;
    KEY_C               :: 67;
    KEY_D               :: 68;
    KEY_E               :: 69;
    KEY_F               :: 70;
    KEY_G               :: 71;
    KEY_H               :: 72;
    KEY_I               :: 73;
    KEY_J               :: 74;
    KEY_K               :: 75;
    KEY_L               :: 76;
    KEY_M               :: 77;
    KEY_N               :: 78;
    KEY_O               :: 79;
    KEY_P               :: 80;
    KEY_Q               :: 81;
    KEY_R               :: 82;
    KEY_S               :: 83;
    KEY_T               :: 84;
    KEY_U               :: 85;
    KEY_V               :: 86;
    KEY_W               :: 87;
    KEY_X               :: 88;
    KEY_Y               :: 89;
    KEY_Z               :: 90;

    // Function keys
    KEY_SPACE           :: 32;
    KEY_ESCAPE          :: 256;
    KEY_ENTER           :: 257;
    KEY_TAB             :: 258;
    KEY_BACKSPACE       :: 259;
    KEY_INSERT          :: 260;
    KEY_DELETE          :: 261;
    KEY_RIGHT           :: 262;
    KEY_LEFT            :: 263;
    KEY_DOWN            :: 264;
    KEY_UP              :: 265;
    KEY_PAGE_UP         :: 266;
    KEY_PAGE_DOWN       :: 267;
    KEY_HOME            :: 268;
    KEY_END             :: 269;
    KEY_CAPS_LOCK       :: 280;
    KEY_SCROLL_LOCK     :: 281;
    KEY_NUM_LOCK        :: 282;
    KEY_PRINT_SCREEN    :: 283;
    KEY_PAUSE           :: 284;
    KEY_F1              :: 290;
    KEY_F2              :: 291;
    KEY_F3              :: 292;
    KEY_F4              :: 293;
    KEY_F5              :: 294;
    KEY_F6              :: 295;
    KEY_F7              :: 296;
    KEY_F8              :: 297;
    KEY_F9              :: 298;
    KEY_F10             :: 299;
    KEY_F11             :: 300;
    KEY_F12             :: 301;
    KEY_LEFT_SHIFT      :: 340;
    KEY_LEFT_CONTROL    :: 341;
    KEY_LEFT_ALT        :: 342;
    KEY_LEFT_SUPER      :: 343;
    KEY_RIGHT_SHIFT     :: 344;
    KEY_RIGHT_CONTROL   :: 345;
    KEY_RIGHT_ALT       :: 346;
    KEY_RIGHT_SUPER     :: 347;
    KEY_KB_MENU         :: 348;
    KEY_LEFT_BRACKET    :: 91;
    KEY_BACKSLASH       :: 92;
    KEY_RIGHT_BRACKET   :: 93;
    KEY_GRAVE           :: 96;

    // Keypad keys
    KEY_KP_0            :: 320;
    KEY_KP_1            :: 321;
    KEY_KP_2            :: 322;
    KEY_KP_3            :: 323;
    KEY_KP_4            :: 324;
    KEY_KP_5            :: 325;
    KEY_KP_6            :: 326;
    KEY_KP_7            :: 327;
    KEY_KP_8            :: 328;
    KEY_KP_9            :: 329;
    KEY_KP_DECIMAL      :: 330;
    KEY_KP_DIVIDE       :: 331;
    KEY_KP_MULTIPLY     :: 332;
    KEY_KP_SUBTRACT     :: 333;
    KEY_KP_ADD          :: 334;
    KEY_KP_ENTER        :: 335;
    KEY_KP_EQUAL        :: 336;
}

AndroidButton :: enum {
    KEY_BACK            :: 4;
    KEY_MENU            :: 82;
    KEY_VOLUME_UP       :: 24;
    KEY_VOLUME_DOWN     :: 25;
}

MouseButton :: enum {
    MOUSE_LEFT_BUTTON   :: 0;
    MOUSE_RIGHT_BUTTON  :: 1;
    MOUSE_MIDDLE_BUTTON :: 2;
}

GamepadNumber :: enum {
    GAMEPAD_PLAYER1     :: 0;
    GAMEPAD_PLAYER2     :: 1;
    GAMEPAD_PLAYER3     :: 2;
    GAMEPAD_PLAYER4     :: 3;
}

GamepadButton :: enum {
    // This is here just for error checking
    GAMEPAD_BUTTON_UNKNOWN :: 0;

    // This is normally a DPAD
    GAMEPAD_BUTTON_LEFT_FACE_UP;
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT;
    GAMEPAD_BUTTON_LEFT_FACE_DOWN;
    GAMEPAD_BUTTON_LEFT_FACE_LEFT;

    // This normally corresponds with PlayStation and Xbox controllers
    // XBOX: [Y;X;A;B]
    // PS3: [Triangle;Square;Cross;Circle]
    // No support for 6 button controllers though..
    GAMEPAD_BUTTON_RIGHT_FACE_UP;
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT;
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN;
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT;

    // Triggers
    GAMEPAD_BUTTON_LEFT_TRIGGER_1;
    GAMEPAD_BUTTON_LEFT_TRIGGER_2;
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1;
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2;

    // These are buttons in the center of the gamepad
    GAMEPAD_BUTTON_MIDDLE_LEFT;     //PS3 Select
    GAMEPAD_BUTTON_MIDDLE;          //PS Button/XBOX Button
    GAMEPAD_BUTTON_MIDDLE_RIGHT;    //PS3 Start

    // These are the joystick press in buttons
    GAMEPAD_BUTTON_LEFT_THUMB;
    GAMEPAD_BUTTON_RIGHT_THUMB;
}

GamepadAxis :: enum {
    // This is here just for error checking
    GAMEPAD_AXIS_UNKNOWN :: 0;

    // Left stick
    GAMEPAD_AXIS_LEFT_X;
    GAMEPAD_AXIS_LEFT_Y;

    // Right stick
    GAMEPAD_AXIS_RIGHT_X;
    GAMEPAD_AXIS_RIGHT_Y;

    // Pressure levels for the back triggers
    GAMEPAD_AXIS_LEFT_TRIGGER;      // [1..-1] (pressure-level)
    GAMEPAD_AXIS_RIGHT_TRIGGER;
}

ShaderLocationIndex :: enum {
    LOC_VERTEX_POSITION :: 0;
    LOC_VERTEX_TEXCOORD01;
    LOC_VERTEX_TEXCOORD02;
    LOC_VERTEX_NORMAL;
    LOC_VERTEX_TANGENT;
    LOC_VERTEX_COLOR;
    LOC_MATRIX_MVP;
    LOC_MATRIX_MODEL;
    LOC_MATRIX_VIEW;
    LOC_MATRIX_PROJECTION;
    LOC_VECTOR_VIEW;
    LOC_COLOR_DIFFUSE;
    LOC_COLOR_SPECULAR;
    LOC_COLOR_AMBIENT;
    LOC_MAP_ALBEDO;          // LOC_MAP_DIFFUSE
    LOC_MAP_METALNESS;       // LOC_MAP_SPECULAR
    LOC_MAP_NORMAL;
    LOC_MAP_ROUGHNESS;
    LOC_MAP_OCCLUSION;
    LOC_MAP_EMISSION;
    LOC_MAP_HEIGHT;
    LOC_MAP_CUBEMAP;
    LOC_MAP_IRRADIANCE;
    LOC_MAP_PREFILTER;
    LOC_MAP_BRDF;
}

ShaderUniformDataType :: enum {
    UNIFORM_FLOAT :: 0;
    UNIFORM_VEC2;
    UNIFORM_VEC3;
    UNIFORM_VEC4;
    UNIFORM_INT;
    UNIFORM_IVEC2;
    UNIFORM_IVEC3;
    UNIFORM_IVEC4;
    UNIFORM_SAMPLER2D;
}

MaterialMapType :: enum {
    MAP_ALBEDO    :: 0;       // MAP_DIFFUSE
    MAP_METALNESS :: 1;       // MAP_SPECULAR
    MAP_NORMAL    :: 2;
    MAP_ROUGHNESS :: 3;
    MAP_OCCLUSION;
    MAP_EMISSION;
    MAP_HEIGHT;
    MAP_CUBEMAP;             // NOTE: Uses GL_TEXTURE_CUBE_MAP
    MAP_IRRADIANCE;          // NOTE: Uses GL_TEXTURE_CUBE_MAP
    MAP_PREFILTER;           // NOTE: Uses GL_TEXTURE_CUBE_MAP
    MAP_BRDF;
}

PixelFormat :: enum {
    UNCOMPRESSED_GRAYSCALE :: 1;     // 8 bit per pixel (no alpha)
    UNCOMPRESSED_GRAY_ALPHA;        // 8*2 bpp (2 channels)
    UNCOMPRESSED_R5G6B5;            // 16 bpp
    UNCOMPRESSED_R8G8B8;            // 24 bpp
    UNCOMPRESSED_R5G5B5A1;          // 16 bpp (1 bit alpha)
    UNCOMPRESSED_R4G4B4A4;          // 16 bpp (4 bit alpha)
    UNCOMPRESSED_R8G8B8A8;          // 32 bpp
    UNCOMPRESSED_R32;               // 32 bpp (1 channel - float)
    UNCOMPRESSED_R32G32B32;         // 32*3 bpp (3 channels - float)
    UNCOMPRESSED_R32G32B32A32;      // 32*4 bpp (4 channels - float)
    COMPRESSED_DXT1_RGB;            // 4 bpp (no alpha)
    COMPRESSED_DXT1_RGBA;           // 4 bpp (1 bit alpha)
    COMPRESSED_DXT3_RGBA;           // 8 bpp
    COMPRESSED_DXT5_RGBA;           // 8 bpp
    COMPRESSED_ETC1_RGB;            // 4 bpp
    COMPRESSED_ETC2_RGB;            // 4 bpp
    COMPRESSED_ETC2_EAC_RGBA;       // 8 bpp
    COMPRESSED_PVRT_RGB;            // 4 bpp
    COMPRESSED_PVRT_RGBA;           // 4 bpp
    COMPRESSED_ASTC_4x4_RGBA;       // 8 bpp
    COMPRESSED_ASTC_8x8_RGBA;
}

TextureFilterMode :: enum {
    FILTER_POINT :: 0;               // No filter; just pixel aproximation
    FILTER_BILINEAR;                // Linear filtering
    FILTER_TRILINEAR;               // Trilinear filtering (linear with mipmaps)
    FILTER_ANISOTROPIC_4X;          // Anisotropic filtering 4x
    FILTER_ANISOTROPIC_8X;          // Anisotropic filtering 8x
    FILTER_ANISOTROPIC_16X;;
}

CubemapLayoutType :: enum {
    CUBEMAP_AUTO_DETECT :: 0;        // Automatically detect layout type
    CUBEMAP_LINE_VERTICAL;          // Layout is defined by a vertical line with faces
    CUBEMAP_LINE_HORIZONTAL;        // Layout is defined by an horizontal line with faces
    CUBEMAP_CROSS_THREE_BY_FOUR;    // Layout is defined by a 3x4 cross with cubemap faces
    CUBEMAP_CROSS_FOUR_BY_THREE;    // Layout is defined by a 4x3 cross with cubemap faces
    CUBEMAP_PANORAMA;
}

TextureWrapMode :: enum {
    WRAP_REPEAT :: 0;        // Repeats texture in tiled mode
    WRAP_CLAMP;             // Clamps texture to edge pixel in tiled mode
    WRAP_MIRROR_REPEAT;     // Mirrors and repeats the texture in tiled mode
    WRAP_MIRROR_CLAMP;
}

FontType :: enum {
    FONT_DEFAULT :: 0;       // Default font generation; anti-aliased
    FONT_BITMAP;            // Bitmap font generation; no anti-aliasing
    FONT_SDF;
}

BlendMode :: enum {
    BLEND_ALPHA :: 0;        // Blend textures considering alpha (default)
    BLEND_ADDITIVE;         // Blend textures adding colors
    BLEND_MULTIPLIED;
}

GestureType :: enum {
    GESTURE_NONE        :: 0;
    GESTURE_TAP         :: 1;
    GESTURE_DOUBLETAP   :: 2;
    GESTURE_HOLD        :: 4;
    GESTURE_DRAG        :: 8;
    GESTURE_SWIPE_RIGHT :: 16;
    GESTURE_SWIPE_LEFT  :: 32;
    GESTURE_SWIPE_UP    :: 64;
    GESTURE_SWIPE_DOWN  :: 128;
    GESTURE_PINCH_IN    :: 256;
    GESTURE_PINCH_OUT   :: 512;
}

CameraMode :: enum {
    CAMERA_CUSTOM :: 0;
    CAMERA_FREE;
    CAMERA_ORBITAL;
    CAMERA_FIRST_PERSON;
    CAMERA_THIRD_PERSON;
}

CameraType :: enum {
    CAMERA_PERSPECTIVE :: 0;
    CAMERA_ORTHOGRAPHIC;
}

NPatchType :: enum {
    NPT_9PATCH :: 0;         // Npatch defined by 3x3 tiles
    NPT_3PATCH_VERTICAL;    // Npatch defined by 1x3 tiles
    NPT_3PATCH_HORIZONTAL;
}

rAudioBuffer :: struct { /* only used as a pointer in this header */ }

Quaternion :: Vector4;

Texture :: Texture2D;

TextureCubemap :: Texture2D;

RenderTexture :: RenderTexture2D;

Camera :: Camera3D;

Vector2 :: struct {
    x: float;
    y: float;
}

Vector3 :: struct {
    x: float;
    y: float;
    z: float;
}

Vector4 :: struct {
    x: float;
    y: float;
    z: float;
    w: float;
}

Matrix :: struct {
    m0, m4, m8, m12: float;
    m1, m5, m9, m13: float;
    m2, m6, m10, m14: float;
    m3, m7, m11, m15: float;
}

Color :: struct {
    r: u8;
    g: u8;
    b: u8;
    a: u8;
}

Rectangle :: struct {
    x: float;
    y: float;
    width: float;
    height: float;
}

Image :: struct {
    data: *void;
    width: s32;
    height: s32;
    mipmaps: s32;
    format: s32;
}

Texture2D :: struct {
    id: u32;
    width: s32;
    height: s32;
    mipmaps: s32;
    format: s32;
}

RenderTexture2D :: struct {
    id: u32;
    texture: Texture2D;
    depth: Texture2D;
    depthTexture: bool;
}

NPatchInfo :: struct {
    sourceRec: Rectangle;
    left: s32;
    top: s32;
    right: s32;
    bottom: s32;
    type: s32;
}

CharInfo :: struct {
    value: s32;
    offsetX: s32;
    offsetY: s32;
    advanceX: s32;
    image: Image;
}

Font :: struct {
    baseSize: s32;
    charsCount: s32;
    texture: Texture2D;
    recs: *Rectangle;
    chars: *CharInfo;
}

Camera3D :: struct {
    position: Vector3;
    target: Vector3;
    up: Vector3;
    fovy: float;
    type: CameraType;
}

Camera2D :: struct {
    offset: Vector2;
    target: Vector2;
    rotation: float;
    zoom: float;
}

Mesh :: struct {
    vertexCount: s32;
    triangleCount: s32;
    vertices: *float;
    texcoords: *float;
    texcoords2: *float;
    normals: *float;
    tangents: *float;
    colors: *u8;
    indices: *u16;
    animVertices: *float;
    animNormals: *float;
    boneIds: *s32;
    boneWeights: *float;
    vaoId: u32;
    vboId: *u32;
}

Shader :: struct {
    id: u32;
    locs: *s32;
}

MaterialMap :: struct {
    texture: Texture2D;
    color: Color;
    value: float;
}

Material :: struct {
    shader: Shader;
    maps: *MaterialMap;
    params: *float;
}

Transform :: struct {
    translation: Vector3;
    rotation: Quaternion;
    scale: Vector3;
}

BoneInfo :: struct {
    name: s8;
    parent: s32;
}

Model :: struct {
    transform: Matrix;
    meshCount: s32;
    meshes: *Mesh;
    materialCount: s32;
    materials: *Material;
    meshMaterial: *s32;
    boneCount: s32;
    bones: *BoneInfo;
    bindPose: *Transform;
}

ModelAnimation :: struct {
    boneCount: s32;
    bones: *BoneInfo;
    frameCount: s32;
    framePoses: **Transform;
}

Ray :: struct {
    position: Vector3;
    direction: Vector3;
}

RayHitInfo :: struct {
    hit: bool;
    distance: float;
    position: Vector3;
    normal: Vector3;
}

BoundingBox :: struct {
    min: Vector3;
    max: Vector3;
}

Wave :: struct {
    sampleCount: u32;
    sampleRate: u32;
    sampleSize: u32;
    channels: u32;
    data: *void;
}

AudioStream :: struct {
    sampleRate: u32;
    sampleSize: u32;
    channels: u32;
    buffer: *rAudioBuffer;
}

Sound :: struct {
    sampleCount: u32;
    stream: AudioStream;
}

Music :: struct {
    ctxType: s32;
    ctxData: *void;
    sampleCount: u32;
    loopCount: u32;
    stream: AudioStream;
}

VrDeviceInfo :: struct {
    hResolution: s32;
    vResolution: s32;
    hScreenSize: float;
    vScreenSize: float;
    vScreenCenter: float;
    eyeToScreenDistance: float;
    lensSeparationDistance: float;
    interpupillaryDistance: float;
    lensDistortionValues: float;
    chromaAbCorrection: float;
}

InitWindow :: (width: s32, height: s32, title: *u8)  #foreign raylib_native "InitWindow";
WindowShouldClose :: () -> bool #foreign raylib_native "WindowShouldClose";
CloseWindow :: ()  #foreign raylib_native "CloseWindow";
IsWindowReady :: () -> bool #foreign raylib_native "IsWindowReady";
IsWindowMinimized :: () -> bool #foreign raylib_native "IsWindowMinimized";
IsWindowResized :: () -> bool #foreign raylib_native "IsWindowResized";
IsWindowHidden :: () -> bool #foreign raylib_native "IsWindowHidden";
IsWindowFullscreen :: () -> bool #foreign raylib_native "IsWindowFullscreen";
ToggleFullscreen :: ()  #foreign raylib_native "ToggleFullscreen";
UnhideWindow :: ()  #foreign raylib_native "UnhideWindow";
HideWindow :: ()  #foreign raylib_native "HideWindow";
SetWindowIcon :: (image: Image)  #foreign raylib_native "SetWindowIcon";
SetWindowTitle :: (title: *u8)  #foreign raylib_native "SetWindowTitle";
SetWindowPosition :: (x: s32, y: s32)  #foreign raylib_native "SetWindowPosition";
SetWindowMonitor :: (monitor: s32)  #foreign raylib_native "SetWindowMonitor";
SetWindowMinSize :: (width: s32, height: s32)  #foreign raylib_native "SetWindowMinSize";
SetWindowSize :: (width: s32, height: s32)  #foreign raylib_native "SetWindowSize";
GetWindowHandle :: () -> *void #foreign raylib_native "GetWindowHandle";
GetScreenWidth :: () -> s32 #foreign raylib_native "GetScreenWidth";
GetScreenHeight :: () -> s32 #foreign raylib_native "GetScreenHeight";
GetMonitorCount :: () -> s32 #foreign raylib_native "GetMonitorCount";
GetMonitorWidth :: (monitor: s32) -> s32 #foreign raylib_native "GetMonitorWidth";
GetMonitorHeight :: (monitor: s32) -> s32 #foreign raylib_native "GetMonitorHeight";
GetMonitorPhysicalWidth :: (monitor: s32) -> s32 #foreign raylib_native "GetMonitorPhysicalWidth";
GetMonitorPhysicalHeight :: (monitor: s32) -> s32 #foreign raylib_native "GetMonitorPhysicalHeight";
GetWindowPosition :: () -> Vector2 #foreign raylib_native "GetWindowPosition";
GetMonitorName :: (monitor: s32) -> *u8 #foreign raylib_native "GetMonitorName";
GetClipboardText :: () -> *u8 #foreign raylib_native "GetClipboardText";
SetClipboardText :: (text: *u8)  #foreign raylib_native "SetClipboardText";
ShowCursor :: ()  #foreign raylib_native "ShowCursor";
HideCursor :: ()  #foreign raylib_native "HideCursor";
IsCursorHidden :: () -> bool #foreign raylib_native "IsCursorHidden";
EnableCursor :: ()  #foreign raylib_native "EnableCursor";
DisableCursor :: ()  #foreign raylib_native "DisableCursor";
ClearBackground :: (color: Color)  #foreign raylib_native "ClearBackground";
BeginDrawing :: ()  #foreign raylib_native "BeginDrawing";
EndDrawing :: ()  #foreign raylib_native "EndDrawing";
BeginMode2D :: (camera: Camera2D)  #foreign raylib_native "BeginMode2D";
EndMode2D :: ()  #foreign raylib_native "EndMode2D";
BeginMode3D :: (camera: Camera3D)  #foreign raylib_native "BeginMode3D";
EndMode3D :: ()  #foreign raylib_native "EndMode3D";
BeginTextureMode :: (target: RenderTexture2D)  #foreign raylib_native "BeginTextureMode";
EndTextureMode :: ()  #foreign raylib_native "EndTextureMode";
BeginScissorMode :: (x: s32, y: s32, width: s32, height: s32)  #foreign raylib_native "BeginScissorMode";
EndScissorMode :: ()  #foreign raylib_native "EndScissorMode";
GetMouseRay :: (mousePosition: Vector2, camera: Camera) -> Ray #foreign raylib_native "GetMouseRay";
GetCameraMatrix :: (camera: Camera) -> Matrix #foreign raylib_native "GetCameraMatrix";
GetCameraMatrix2D :: (camera: Camera2D) -> Matrix #foreign raylib_native "GetCameraMatrix2D";
GetWorldToScreen :: (position: Vector3, camera: Camera) -> Vector2 #foreign raylib_native "GetWorldToScreen";
GetWorldToScreenEx :: (position: Vector3, camera: Camera, width: s32, height: s32) -> Vector2 #foreign raylib_native "GetWorldToScreenEx";
GetWorldToScreen2D :: (position: Vector2, camera: Camera2D) -> Vector2 #foreign raylib_native "GetWorldToScreen2D";
GetScreenToWorld2D :: (position: Vector2, camera: Camera2D) -> Vector2 #foreign raylib_native "GetScreenToWorld2D";
SetTargetFPS :: (fps: s32)  #foreign raylib_native "SetTargetFPS";
GetFPS :: () -> s32 #foreign raylib_native "GetFPS";
GetFrameTime :: () -> float #foreign raylib_native "GetFrameTime";
GetTime :: () -> float64 #foreign raylib_native "GetTime";
ColorToInt :: (color: Color) -> s32 #foreign raylib_native "ColorToInt";
ColorNormalize :: (color: Color) -> Vector4 #foreign raylib_native "ColorNormalize";
ColorFromNormalized :: (normalized: Vector4) -> Color #foreign raylib_native "ColorFromNormalized";
ColorToHSV :: (color: Color) -> Vector3 #foreign raylib_native "ColorToHSV";
ColorFromHSV :: (hsv: Vector3) -> Color #foreign raylib_native "ColorFromHSV";
GetColor :: (hexValue: s32) -> Color #foreign raylib_native "GetColor";
Fade :: (color: Color, alpha: float) -> Color #foreign raylib_native "Fade";
SetConfigFlags :: (flags: ConfigFlag) #foreign raylib_native "SetConfigFlags";
SetTraceLogLevel :: (logType: TraceLogType) #foreign raylib_native "SetTraceLogLevel";
SetTraceLogExit :: (logType: TraceLogType) #foreign raylib_native "SetTraceLogExit";
SetTraceLogCallback :: (callback: TraceLogCallback)  #foreign raylib_native "SetTraceLogCallback";
TraceLog :: (logType: s32, text: *u8, args: ..*u8)  #foreign raylib_native "TraceLog";
TakeScreenshot :: (fileName: *u8)  #foreign raylib_native "TakeScreenshot";
GetRandomValue :: (min: s32, max: s32) -> s32 #foreign raylib_native "GetRandomValue";
LoadFileData :: (fileName: *u8, bytesRead: *u32) -> *u8 #foreign raylib_native "LoadFileData";
SaveFileData :: (fileName: *u8, data: *void, bytesToWrite: u32)  #foreign raylib_native "SaveFileData";
LoadFileText :: (fileName: *u8) -> *s8 #foreign raylib_native "LoadFileText";
SaveFileText :: (fileName: *u8, text: *s8)  #foreign raylib_native "SaveFileText";
FileExists :: (fileName: *u8) -> bool #foreign raylib_native "FileExists";
IsFileExtension :: (fileName: *u8, ext: *u8) -> bool #foreign raylib_native "IsFileExtension";
DirectoryExists :: (dirPath: *u8) -> bool #foreign raylib_native "DirectoryExists";
GetExtension :: (fileName: *u8) -> *u8 #foreign raylib_native "GetExtension";
GetFileName :: (filePath: *u8) -> *u8 #foreign raylib_native "GetFileName";
GetFileNameWithoutExt :: (filePath: *u8) -> *u8 #foreign raylib_native "GetFileNameWithoutExt";
GetDirectoryPath :: (filePath: *u8) -> *u8 #foreign raylib_native "GetDirectoryPath";
GetPrevDirectoryPath :: (dirPath: *u8) -> *u8 #foreign raylib_native "GetPrevDirectoryPath";
GetWorkingDirectory :: () -> *u8 #foreign raylib_native "GetWorkingDirectory";
GetDirectoryFiles :: (dirPath: *u8, count: *s32) -> **s8 #foreign raylib_native "GetDirectoryFiles";
ClearDirectoryFiles :: ()  #foreign raylib_native "ClearDirectoryFiles";
ChangeDirectory :: (dir: *u8) -> bool #foreign raylib_native "ChangeDirectory";
IsFileDropped :: () -> bool #foreign raylib_native "IsFileDropped";
GetDroppedFiles :: (count: *s32) -> **s8 #foreign raylib_native "GetDroppedFiles";
ClearDroppedFiles :: ()  #foreign raylib_native "ClearDroppedFiles";
GetFileModTime :: (fileName: *u8) -> s32 #foreign raylib_native "GetFileModTime";
CompressData :: (data: *u8, dataLength: s32, compDataLength: *s32) -> *u8 #foreign raylib_native "CompressData";
DecompressData :: (compData: *u8, compDataLength: s32, dataLength: *s32) -> *u8 #foreign raylib_native "DecompressData";
SaveStorageValue :: (position: u32, value: s32)  #foreign raylib_native "SaveStorageValue";
LoadStorageValue :: (position: u32) -> s32 #foreign raylib_native "LoadStorageValue";
OpenURL :: (url: *u8)  #foreign raylib_native "OpenURL";
IsKeyPressed :: (key: KeyboardKey) -> bool #foreign raylib_native "IsKeyPressed";
IsKeyDown :: (key: KeyboardKey) -> bool #foreign raylib_native "IsKeyDown";
IsKeyReleased :: (key: KeyboardKey) -> bool #foreign raylib_native "IsKeyReleased";
IsKeyUp :: (key: KeyboardKey) -> bool #foreign raylib_native "IsKeyUp";
SetExitKey :: (key: KeyboardKey) -> bool #foreign raylib_native "SetExitKey";
GetKeyPressed :: () -> s32 #foreign raylib_native "GetKeyPressed";
IsGamepadAvailable :: (gamepad: s32) -> bool #foreign raylib_native "IsGamepadAvailable";
IsGamepadName :: (gamepad: s32, name: *u8) -> bool #foreign raylib_native "IsGamepadName";
GetGamepadName :: (gamepad: s32) -> *u8 #foreign raylib_native "GetGamepadName";
IsGamepadButtonPressed :: (gamepad: int, button: GamepadButton) -> bool #foreign raylib_native "IsGamepadButtonPressed";
IsGamepadButtonDown :: (gamepad: int, button: GamepadButton) -> bool #foreign raylib_native "IsGamepadButtonDown";
IsGamepadButtonReleased :: (gamepad: int, button: GamepadButton) -> bool #foreign raylib_native "IsGamepadButtonReleased";
IsGamepadButtonUp :: (gamepad: int, button: GamepadButton) -> bool #foreign raylib_native "IsGamepadButtonUp";
GetGamepadButtonPressed :: () -> s32 #foreign raylib_native "GetGamepadButtonPressed";
GetGamepadAxisCount :: (gamepad: s32) -> s32 #foreign raylib_native "GetGamepadAxisCount";
GetGamepadAxisMovement :: (gamepad: int, axis: GamepadAxis) -> float #foreign raylib_native "GetGamepadAxisMovement";
IsMouseButtonPressed :: (button: MouseButton) -> bool #foreign raylib_native "IsMouseButtonPressed";
IsMouseButtonDown :: (button: MouseButton) -> bool #foreign raylib_native "IsMouseButtonDown";
IsMouseButtonReleased :: (button: MouseButton) -> bool #foreign raylib_native "IsMouseButtonReleased";
IsMouseButtonUp :: (button: MouseButton) -> bool #foreign raylib_native "IsMouseButtonUp";
GetMouseX :: () -> s32 #foreign raylib_native "GetMouseX";
GetMouseY :: () -> s32 #foreign raylib_native "GetMouseY";
GetMousePosition :: () -> Vector2 #foreign raylib_native "GetMousePosition";
SetMousePosition :: (x: s32, y: s32)  #foreign raylib_native "SetMousePosition";
SetMouseOffset :: (offsetX: s32, offsetY: s32)  #foreign raylib_native "SetMouseOffset";
SetMouseScale :: (scaleX: float, scaleY: float)  #foreign raylib_native "SetMouseScale";
GetMouseWheelMove :: () -> s32 #foreign raylib_native "GetMouseWheelMove";
GetTouchX :: () -> s32 #foreign raylib_native "GetTouchX";
GetTouchY :: () -> s32 #foreign raylib_native "GetTouchY";
GetTouchPosition :: (index: s32) -> Vector2 #foreign raylib_native "GetTouchPosition";
SetGesturesEnabled :: (gestureFlags: u32)  #foreign raylib_native "SetGesturesEnabled";
IsGestureDetected :: (gesture: s32) -> bool #foreign raylib_native "IsGestureDetected";
GetGestureDetected :: () -> s32 #foreign raylib_native "GetGestureDetected";
GetTouchPointsCount :: () -> s32 #foreign raylib_native "GetTouchPointsCount";
GetGestureHoldDuration :: () -> float #foreign raylib_native "GetGestureHoldDuration";
GetGestureDragVector :: () -> Vector2 #foreign raylib_native "GetGestureDragVector";
GetGestureDragAngle :: () -> float #foreign raylib_native "GetGestureDragAngle";
GetGesturePinchVector :: () -> Vector2 #foreign raylib_native "GetGesturePinchVector";
GetGesturePinchAngle :: () -> float #foreign raylib_native "GetGesturePinchAngle";
SetCameraMode :: (camera: Camera, mode: CameraMode) #foreign raylib_native "SetCameraMode";
UpdateCamera :: (camera: *Camera)  #foreign raylib_native "UpdateCamera";
SetCameraPanControl :: (panKey: s32)  #foreign raylib_native "SetCameraPanControl";
SetCameraAltControl :: (altKey: s32)  #foreign raylib_native "SetCameraAltControl";
SetCameraSmoothZoomControl :: (szKey: s32)  #foreign raylib_native "SetCameraSmoothZoomControl";
SetCameraMoveControls :: (frontKey: s32, backKey: s32, rightKey: s32, leftKey: s32, upKey: s32, downKey: s32)  #foreign raylib_native "SetCameraMoveControls";
DrawPixel :: (posX: s32, posY: s32, color: Color)  #foreign raylib_native "DrawPixel";
DrawPixelV :: (position: Vector2, color: Color)  #foreign raylib_native "DrawPixelV";
DrawLine :: (startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color)  #foreign raylib_native "DrawLine";
DrawLineV :: (startPos: Vector2, endPos: Vector2, color: Color)  #foreign raylib_native "DrawLineV";
DrawLineEx :: (startPos: Vector2, endPos: Vector2, thick: float, color: Color)  #foreign raylib_native "DrawLineEx";
DrawLineBezier :: (startPos: Vector2, endPos: Vector2, thick: float, color: Color)  #foreign raylib_native "DrawLineBezier";
DrawLineStrip :: (points: *Vector2, numPoints: s32, color: Color)  #foreign raylib_native "DrawLineStrip";
DrawCircle :: (centerX: s32, centerY: s32, radius: float, color: Color)  #foreign raylib_native "DrawCircle";
DrawCircleSector :: (center: Vector2, radius: float, startAngle: s32, endAngle: s32, segments: s32, color: Color)  #foreign raylib_native "DrawCircleSector";
DrawCircleSectorLines :: (center: Vector2, radius: float, startAngle: s32, endAngle: s32, segments: s32, color: Color)  #foreign raylib_native "DrawCircleSectorLines";
DrawCircleGradient :: (centerX: s32, centerY: s32, radius: float, color1: Color, color2: Color)  #foreign raylib_native "DrawCircleGradient";
DrawCircleV :: (center: Vector2, radius: float, color: Color)  #foreign raylib_native "DrawCircleV";
DrawCircleLines :: (centerX: s32, centerY: s32, radius: float, color: Color)  #foreign raylib_native "DrawCircleLines";
DrawEllipse :: (centerX: s32, centerY: s32, radiusH: float, radiusV: float, color: Color)  #foreign raylib_native "DrawEllipse";
DrawEllipseLines :: (centerX: s32, centerY: s32, radiusH: float, radiusV: float, color: Color)  #foreign raylib_native "DrawEllipseLines";
DrawRing :: (center: Vector2, innerRadius: float, outerRadius: float, startAngle: s32, endAngle: s32, segments: s32, color: Color)  #foreign raylib_native "DrawRing";
DrawRingLines :: (center: Vector2, innerRadius: float, outerRadius: float, startAngle: s32, endAngle: s32, segments: s32, color: Color)  #foreign raylib_native "DrawRingLines";
DrawRectangle :: (posX: s32, posY: s32, width: s32, height: s32, color: Color)  #foreign raylib_native "DrawRectangle";
DrawRectangleV :: (position: Vector2, size: Vector2, color: Color)  #foreign raylib_native "DrawRectangleV";
DrawRectangleRec :: (rec: Rectangle, color: Color)  #foreign raylib_native "DrawRectangleRec";
DrawRectanglePro :: (rec: Rectangle, origin: Vector2, rotation: float, color: Color)  #foreign raylib_native "DrawRectanglePro";
DrawRectangleGradientV :: (posX: s32, posY: s32, width: s32, height: s32, color1: Color, color2: Color)  #foreign raylib_native "DrawRectangleGradientV";
DrawRectangleGradientH :: (posX: s32, posY: s32, width: s32, height: s32, color1: Color, color2: Color)  #foreign raylib_native "DrawRectangleGradientH";
DrawRectangleGradientEx :: (rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)  #foreign raylib_native "DrawRectangleGradientEx";
DrawRectangleLines :: (posX: s32, posY: s32, width: s32, height: s32, color: Color)  #foreign raylib_native "DrawRectangleLines";
DrawRectangleLinesEx :: (rec: Rectangle, lineThick: s32, color: Color)  #foreign raylib_native "DrawRectangleLinesEx";
DrawRectangleRounded :: (rec: Rectangle, roundness: float, segments: s32, color: Color)  #foreign raylib_native "DrawRectangleRounded";
DrawRectangleRoundedLines :: (rec: Rectangle, roundness: float, segments: s32, lineThick: s32, color: Color)  #foreign raylib_native "DrawRectangleRoundedLines";
DrawTriangle :: (v1: Vector2, v2: Vector2, v3: Vector2, color: Color)  #foreign raylib_native "DrawTriangle";
DrawTriangleLines :: (v1: Vector2, v2: Vector2, v3: Vector2, color: Color)  #foreign raylib_native "DrawTriangleLines";
DrawTriangleFan :: (points: *Vector2, numPoints: s32, color: Color)  #foreign raylib_native "DrawTriangleFan";
DrawTriangleStrip :: (points: *Vector2, pointsCount: s32, color: Color)  #foreign raylib_native "DrawTriangleStrip";
DrawPoly :: (center: Vector2, sides: s32, radius: float, rotation: float, color: Color)  #foreign raylib_native "DrawPoly";
DrawPolyLines :: (center: Vector2, sides: s32, radius: float, rotation: float, color: Color)  #foreign raylib_native "DrawPolyLines";
CheckCollisionRecs :: (rec1: Rectangle, rec2: Rectangle) -> bool #foreign raylib_native "CheckCollisionRecs";
CheckCollisionCircles :: (center1: Vector2, radius1: float, center2: Vector2, radius2: float) -> bool #foreign raylib_native "CheckCollisionCircles";
CheckCollisionCircleRec :: (center: Vector2, radius: float, rec: Rectangle) -> bool #foreign raylib_native "CheckCollisionCircleRec";
GetCollisionRec :: (rec1: Rectangle, rec2: Rectangle) -> Rectangle #foreign raylib_native "GetCollisionRec";
CheckCollisionPointRec :: (point: Vector2, rec: Rectangle) -> bool #foreign raylib_native "CheckCollisionPointRec";
CheckCollisionPointCircle :: (point: Vector2, center: Vector2, radius: float) -> bool #foreign raylib_native "CheckCollisionPointCircle";
CheckCollisionPointTriangle :: (point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool #foreign raylib_native "CheckCollisionPointTriangle";
LoadImage :: (fileName: *u8) -> Image #foreign raylib_native "LoadImage";
LoadImageEx :: (pixels: *Color, width: s32, height: s32) -> Image #foreign raylib_native "LoadImageEx";
LoadImagePro :: (data: *void, width: s32, height: s32, format: s32) -> Image #foreign raylib_native "LoadImagePro";
LoadImageRaw :: (fileName: *u8, width: s32, height: s32, format: s32, headerSize: s32) -> Image #foreign raylib_native "LoadImageRaw";
UnloadImage :: (image: Image)  #foreign raylib_native "UnloadImage";
ExportImage :: (image: Image, fileName: *u8)  #foreign raylib_native "ExportImage";
ExportImageAsCode :: (image: Image, fileName: *u8)  #foreign raylib_native "ExportImageAsCode";
GetImageData :: (image: Image) -> *Color #foreign raylib_native "GetImageData";
GetImageDataNormalized :: (image: Image) -> *Vector4 #foreign raylib_native "GetImageDataNormalized";
GenImageColor :: (width: s32, height: s32, color: Color) -> Image #foreign raylib_native "GenImageColor";
GenImageGradientV :: (width: s32, height: s32, top: Color, bottom: Color) -> Image #foreign raylib_native "GenImageGradientV";
GenImageGradientH :: (width: s32, height: s32, left: Color, right: Color) -> Image #foreign raylib_native "GenImageGradientH";
GenImageGradientRadial :: (width: s32, height: s32, density: float, inner: Color, outer: Color) -> Image #foreign raylib_native "GenImageGradientRadial";
GenImageChecked :: (width: s32, height: s32, checksX: s32, checksY: s32, col1: Color, col2: Color) -> Image #foreign raylib_native "GenImageChecked";
GenImageWhiteNoise :: (width: s32, height: s32, factor: float) -> Image #foreign raylib_native "GenImageWhiteNoise";
GenImagePerlinNoise :: (width: s32, height: s32, offsetX: s32, offsetY: s32, scale: float) -> Image #foreign raylib_native "GenImagePerlinNoise";
GenImageCellular :: (width: s32, height: s32, tileSize: s32) -> Image #foreign raylib_native "GenImageCellular";
ImageCopy :: (image: Image) -> Image #foreign raylib_native "ImageCopy";
ImageFromImage :: (image: Image, rec: Rectangle) -> Image #foreign raylib_native "ImageFromImage";
ImageText :: (text: *u8, fontSize: s32, color: Color) -> Image #foreign raylib_native "ImageText";
ImageTextEx :: (font: Font, text: *u8, fontSize: float, spacing: float, tint: Color) -> Image #foreign raylib_native "ImageTextEx";
ImageToPOT :: (image: *Image, fillColor: Color)  #foreign raylib_native "ImageToPOT";
ImageFormat :: (image: *Image, newFormat: s32)  #foreign raylib_native "ImageFormat";
ImageAlphaMask :: (image: *Image, alphaMask: Image)  #foreign raylib_native "ImageAlphaMask";
ImageAlphaClear :: (image: *Image, color: Color, threshold: float)  #foreign raylib_native "ImageAlphaClear";
ImageAlphaCrop :: (image: *Image, threshold: float)  #foreign raylib_native "ImageAlphaCrop";
ImageAlphaPremultiply :: (image: *Image)  #foreign raylib_native "ImageAlphaPremultiply";
ImageCrop :: (image: *Image, crop: Rectangle)  #foreign raylib_native "ImageCrop";
ImageResize :: (image: *Image, newWidth: s32, newHeight: s32)  #foreign raylib_native "ImageResize";
ImageResizeNN :: (image: *Image, newWidth: s32, newHeight: s32)  #foreign raylib_native "ImageResizeNN";
ImageResizeCanvas :: (image: *Image, newWidth: s32, newHeight: s32, offsetX: s32, offsetY: s32, color: Color)  #foreign raylib_native "ImageResizeCanvas";
ImageMipmaps :: (image: *Image)  #foreign raylib_native "ImageMipmaps";
ImageDither :: (image: *Image, rBpp: s32, gBpp: s32, bBpp: s32, aBpp: s32)  #foreign raylib_native "ImageDither";
ImageFlipVertical :: (image: *Image)  #foreign raylib_native "ImageFlipVertical";
ImageFlipHorizontal :: (image: *Image)  #foreign raylib_native "ImageFlipHorizontal";
ImageRotateCW :: (image: *Image)  #foreign raylib_native "ImageRotateCW";
ImageRotateCCW :: (image: *Image)  #foreign raylib_native "ImageRotateCCW";
ImageColorTint :: (image: *Image, color: Color)  #foreign raylib_native "ImageColorTint";
ImageColorInvert :: (image: *Image)  #foreign raylib_native "ImageColorInvert";
ImageColorGrayscale :: (image: *Image)  #foreign raylib_native "ImageColorGrayscale";
ImageColorContrast :: (image: *Image, contrast: float)  #foreign raylib_native "ImageColorContrast";
ImageColorBrightness :: (image: *Image, brightness: s32)  #foreign raylib_native "ImageColorBrightness";
ImageColorReplace :: (image: *Image, color: Color, replace: Color)  #foreign raylib_native "ImageColorReplace";
ImageExtractPalette :: (image: Image, maxPaletteSize: s32, extractCount: *s32) -> *Color #foreign raylib_native "ImageExtractPalette";
GetImageAlphaBorder :: (image: Image, threshold: float) -> Rectangle #foreign raylib_native "GetImageAlphaBorder";
ImageClearBackground :: (dst: *Image, color: Color)  #foreign raylib_native "ImageClearBackground";
ImageDrawPixel :: (dst: *Image, posX: s32, posY: s32, color: Color)  #foreign raylib_native "ImageDrawPixel";
ImageDrawPixelV :: (dst: *Image, position: Vector2, color: Color)  #foreign raylib_native "ImageDrawPixelV";
ImageDrawLine :: (dst: *Image, startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color)  #foreign raylib_native "ImageDrawLine";
ImageDrawLineV :: (dst: *Image, start: Vector2, end: Vector2, color: Color)  #foreign raylib_native "ImageDrawLineV";
ImageDrawCircle :: (dst: *Image, centerX: s32, centerY: s32, radius: s32, color: Color)  #foreign raylib_native "ImageDrawCircle";
ImageDrawCircleV :: (dst: *Image, center: Vector2, radius: s32, color: Color)  #foreign raylib_native "ImageDrawCircleV";
ImageDrawRectangle :: (dst: *Image, posX: s32, posY: s32, width: s32, height: s32, color: Color)  #foreign raylib_native "ImageDrawRectangle";
ImageDrawRectangleV :: (dst: *Image, position: Vector2, size: Vector2, color: Color)  #foreign raylib_native "ImageDrawRectangleV";
ImageDrawRectangleRec :: (dst: *Image, rec: Rectangle, color: Color)  #foreign raylib_native "ImageDrawRectangleRec";
ImageDrawRectangleLines :: (dst: *Image, rec: Rectangle, thick: s32, color: Color)  #foreign raylib_native "ImageDrawRectangleLines";
ImageDraw :: (dst: *Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)  #foreign raylib_native "ImageDraw";
ImageDrawText :: (dst: *Image, position: Vector2, text: *u8, fontSize: s32, color: Color)  #foreign raylib_native "ImageDrawText";
ImageDrawTextEx :: (dst: *Image, position: Vector2, font: Font, text: *u8, fontSize: float, spacing: float, color: Color)  #foreign raylib_native "ImageDrawTextEx";
LoadTexture :: (fileName: *u8) -> Texture2D #foreign raylib_native "LoadTexture";
LoadTextureFromImage :: (image: Image) -> Texture2D #foreign raylib_native "LoadTextureFromImage";
LoadTextureCubemap :: (image: Image, layoutType: s32) -> TextureCubemap #foreign raylib_native "LoadTextureCubemap";
LoadRenderTexture :: (width: s32, height: s32) -> RenderTexture2D #foreign raylib_native "LoadRenderTexture";
UnloadTexture :: (texture: Texture2D)  #foreign raylib_native "UnloadTexture";
UnloadRenderTexture :: (target: RenderTexture2D)  #foreign raylib_native "UnloadRenderTexture";
UpdateTexture :: (texture: Texture2D, pixels: *void)  #foreign raylib_native "UpdateTexture";
GetTextureData :: (texture: Texture2D) -> Image #foreign raylib_native "GetTextureData";
GetScreenData :: () -> Image #foreign raylib_native "GetScreenData";
GenTextureMipmaps :: (texture: *Texture2D)  #foreign raylib_native "GenTextureMipmaps";
SetTextureFilter :: (texture: Texture2D, filterMode: s32)  #foreign raylib_native "SetTextureFilter";
SetTextureWrap :: (texture: Texture2D, wrapMode: s32)  #foreign raylib_native "SetTextureWrap";
DrawTexture :: (texture: Texture2D, posX: s32, posY: s32, tint: Color)  #foreign raylib_native "DrawTexture";
DrawTextureV :: (texture: Texture2D, position: Vector2, tint: Color)  #foreign raylib_native "DrawTextureV";
DrawTextureEx :: (texture: Texture2D, position: Vector2, rotation: float, scale: float, tint: Color)  #foreign raylib_native "DrawTextureEx";
DrawTextureRec :: (texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color)  #foreign raylib_native "DrawTextureRec";
DrawTextureQuad :: (texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color)  #foreign raylib_native "DrawTextureQuad";
DrawTexturePro :: (texture: Texture2D, sourceRec: Rectangle, destRec: Rectangle, origin: Vector2, rotation: float, tint: Color)  #foreign raylib_native "DrawTexturePro";
DrawTextureNPatch :: (texture: Texture2D, nPatchInfo: NPatchInfo, destRec: Rectangle, origin: Vector2, rotation: float, tint: Color)  #foreign raylib_native "DrawTextureNPatch";
GetPixelDataSize :: (width: s32, height: s32, format: s32) -> s32 #foreign raylib_native "GetPixelDataSize";
GetFontDefault :: () -> Font #foreign raylib_native "GetFontDefault";
LoadFont :: (fileName: *u8) -> Font #foreign raylib_native "LoadFont";
LoadFontEx :: (fileName: *u8, fontSize: s32, fontChars: *s32, charsCount: s32) -> Font #foreign raylib_native "LoadFontEx";
LoadFontFromImage :: (image: Image, key: Color, firstChar: s32) -> Font #foreign raylib_native "LoadFontFromImage";
LoadFontData :: (fileName: *u8, fontSize: s32, fontChars: *s32, charsCount: s32, type: s32) -> *CharInfo #foreign raylib_native "LoadFontData";
GenImageFontAtlas :: (chars: *CharInfo, recs: **Rectangle, charsCount: s32, fontSize: s32, padding: s32, packMethod: s32) -> Image #foreign raylib_native "GenImageFontAtlas";
UnloadFont :: (font: Font)  #foreign raylib_native "UnloadFont";
DrawFPS :: (posX: s32, posY: s32)  #foreign raylib_native "DrawFPS";
DrawText :: (text: *u8, posX: s32, posY: s32, fontSize: s32, color: Color)  #foreign raylib_native "DrawText";
DrawTextEx :: (font: Font, text: *u8, position: Vector2, fontSize: float, spacing: float, tint: Color)  #foreign raylib_native "DrawTextEx";
DrawTextRec :: (font: Font, text: *u8, rec: Rectangle, fontSize: float, spacing: float, wordWrap: bool, tint: Color)  #foreign raylib_native "DrawTextRec";
DrawTextRecEx :: (font: Font, text: *u8, rec: Rectangle, fontSize: float, spacing: float, wordWrap: bool, tint: Color, selectStart: s32, selectLength: s32, selectTint: Color, selectBackTint: Color)  #foreign raylib_native "DrawTextRecEx";
DrawTextCodepoint :: (font: Font, codepoint: s32, position: Vector2, scale: float, tint: Color)  #foreign raylib_native "DrawTextCodepoint";
MeasureText :: (text: *u8, fontSize: s32) -> s32 #foreign raylib_native "MeasureText";
MeasureTextEx :: (font: Font, text: *u8, fontSize: float, spacing: float) -> Vector2 #foreign raylib_native "MeasureTextEx";
GetGlyphIndex :: (font: Font, codepoint: s32) -> s32 #foreign raylib_native "GetGlyphIndex";
TextCopy :: (dst: *s8, src: *u8) -> s32 #foreign raylib_native "TextCopy";
TextIsEqual :: (text1: *u8, text2: *u8) -> bool #foreign raylib_native "TextIsEqual";
TextLength :: (text: *u8) -> u32 #foreign raylib_native "TextLength";
TextFormat :: (text: *u8, args: ..*u8) -> *u8 #foreign raylib_native "TextFormat";
TextSubtext :: (text: *u8, position: s32, length: s32) -> *u8 #foreign raylib_native "TextSubtext";
TextReplace :: (text: *s8, replace: *u8, by: *u8) -> *s8 #foreign raylib_native "TextReplace";
TextInsert :: (text: *u8, insert: *u8, position: s32) -> *s8 #foreign raylib_native "TextInsert";
TextJoin :: (textList: **u8, count: s32, delimiter: *u8) -> *u8 #foreign raylib_native "TextJoin";
TextSplit :: (text: *u8, delimiter: s8, count: *s32) -> **u8 #foreign raylib_native "TextSplit";
TextAppend :: (text: *s8, append: *u8, position: *s32)  #foreign raylib_native "TextAppend";
TextFindIndex :: (text: *u8, find: *u8) -> s32 #foreign raylib_native "TextFindIndex";
TextToUpper :: (text: *u8) -> *u8 #foreign raylib_native "TextToUpper";
TextToLower :: (text: *u8) -> *u8 #foreign raylib_native "TextToLower";
TextToPascal :: (text: *u8) -> *u8 #foreign raylib_native "TextToPascal";
TextToInteger :: (text: *u8) -> s32 #foreign raylib_native "TextToInteger";
TextToUtf8 :: (codepoints: *s32, length: s32) -> *s8 #foreign raylib_native "TextToUtf8";
GetCodepoints :: (text: *u8, count: *s32) -> *s32 #foreign raylib_native "GetCodepoints";
GetCodepointsCount :: (text: *u8) -> s32 #foreign raylib_native "GetCodepointsCount";
GetNextCodepoint :: (text: *u8, bytesProcessed: *s32) -> s32 #foreign raylib_native "GetNextCodepoint";
CodepointToUtf8 :: (codepoint: s32, byteLength: *s32) -> *u8 #foreign raylib_native "CodepointToUtf8";
DrawLine3D :: (startPos: Vector3, endPos: Vector3, color: Color)  #foreign raylib_native "DrawLine3D";
DrawPoint3D :: (position: Vector3, color: Color)  #foreign raylib_native "DrawPoint3D";
DrawCircle3D :: (center: Vector3, radius: float, rotationAxis: Vector3, rotationAngle: float, color: Color)  #foreign raylib_native "DrawCircle3D";
DrawCube :: (position: Vector3, width: float, height: float, length: float, color: Color)  #foreign raylib_native "DrawCube";
DrawCubeV :: (position: Vector3, size: Vector3, color: Color)  #foreign raylib_native "DrawCubeV";
DrawCubeWires :: (position: Vector3, width: float, height: float, length: float, color: Color)  #foreign raylib_native "DrawCubeWires";
DrawCubeWiresV :: (position: Vector3, size: Vector3, color: Color)  #foreign raylib_native "DrawCubeWiresV";
DrawCubeTexture :: (texture: Texture2D, position: Vector3, width: float, height: float, length: float, color: Color)  #foreign raylib_native "DrawCubeTexture";
DrawSphere :: (centerPos: Vector3, radius: float, color: Color)  #foreign raylib_native "DrawSphere";
DrawSphereEx :: (centerPos: Vector3, radius: float, rings: s32, slices: s32, color: Color)  #foreign raylib_native "DrawSphereEx";
DrawSphereWires :: (centerPos: Vector3, radius: float, rings: s32, slices: s32, color: Color)  #foreign raylib_native "DrawSphereWires";
DrawCylinder :: (position: Vector3, radiusTop: float, radiusBottom: float, height: float, slices: s32, color: Color)  #foreign raylib_native "DrawCylinder";
DrawCylinderWires :: (position: Vector3, radiusTop: float, radiusBottom: float, height: float, slices: s32, color: Color)  #foreign raylib_native "DrawCylinderWires";
DrawPlane :: (centerPos: Vector3, size: Vector2, color: Color)  #foreign raylib_native "DrawPlane";
DrawRay :: (ray: Ray, color: Color)  #foreign raylib_native "DrawRay";
DrawGrid :: (slices: s32, spacing: float)  #foreign raylib_native "DrawGrid";
DrawGizmo :: (position: Vector3)  #foreign raylib_native "DrawGizmo";
LoadModel :: (fileName: *u8) -> Model #foreign raylib_native "LoadModel";
LoadModelFromMesh :: (mesh: Mesh) -> Model #foreign raylib_native "LoadModelFromMesh";
UnloadModel :: (model: Model)  #foreign raylib_native "UnloadModel";
LoadMeshes :: (fileName: *u8, meshCount: *s32) -> *Mesh #foreign raylib_native "LoadMeshes";
ExportMesh :: (mesh: Mesh, fileName: *u8)  #foreign raylib_native "ExportMesh";
UnloadMesh :: (mesh: Mesh)  #foreign raylib_native "UnloadMesh";
LoadMaterials :: (fileName: *u8, materialCount: *s32) -> *Material #foreign raylib_native "LoadMaterials";
LoadMaterialDefault :: () -> Material #foreign raylib_native "LoadMaterialDefault";
UnloadMaterial :: (material: Material)  #foreign raylib_native "UnloadMaterial";
SetMaterialTexture :: (material: *Material, mapType: s32, texture: Texture2D)  #foreign raylib_native "SetMaterialTexture";
SetModelMeshMaterial :: (model: *Model, meshId: s32, materialId: s32)  #foreign raylib_native "SetModelMeshMaterial";
LoadModelAnimations :: (fileName: *u8, animsCount: *s32) -> *ModelAnimation #foreign raylib_native "LoadModelAnimations";
UpdateModelAnimation :: (model: Model, anim: ModelAnimation, frame: s32)  #foreign raylib_native "UpdateModelAnimation";
UnloadModelAnimation :: (anim: ModelAnimation)  #foreign raylib_native "UnloadModelAnimation";
IsModelAnimationValid :: (model: Model, anim: ModelAnimation) -> bool #foreign raylib_native "IsModelAnimationValid";
GenMeshPoly :: (sides: s32, radius: float) -> Mesh #foreign raylib_native "GenMeshPoly";
GenMeshPlane :: (width: float, length: float, resX: s32, resZ: s32) -> Mesh #foreign raylib_native "GenMeshPlane";
GenMeshCube :: (width: float, height: float, length: float) -> Mesh #foreign raylib_native "GenMeshCube";
GenMeshSphere :: (radius: float, rings: s32, slices: s32) -> Mesh #foreign raylib_native "GenMeshSphere";
GenMeshHemiSphere :: (radius: float, rings: s32, slices: s32) -> Mesh #foreign raylib_native "GenMeshHemiSphere";
GenMeshCylinder :: (radius: float, height: float, slices: s32) -> Mesh #foreign raylib_native "GenMeshCylinder";
GenMeshTorus :: (radius: float, size: float, radSeg: s32, sides: s32) -> Mesh #foreign raylib_native "GenMeshTorus";
GenMeshKnot :: (radius: float, size: float, radSeg: s32, sides: s32) -> Mesh #foreign raylib_native "GenMeshKnot";
GenMeshHeightmap :: (heightmap: Image, size: Vector3) -> Mesh #foreign raylib_native "GenMeshHeightmap";
GenMeshCubicmap :: (cubicmap: Image, cubeSize: Vector3) -> Mesh #foreign raylib_native "GenMeshCubicmap";
MeshBoundingBox :: (mesh: Mesh) -> BoundingBox #foreign raylib_native "MeshBoundingBox";
MeshTangents :: (mesh: *Mesh)  #foreign raylib_native "MeshTangents";
MeshBinormals :: (mesh: *Mesh)  #foreign raylib_native "MeshBinormals";
DrawModel :: (model: Model, position: Vector3, scale: float, tint: Color)  #foreign raylib_native "DrawModel";
DrawModelEx :: (model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float, scale: Vector3, tint: Color)  #foreign raylib_native "DrawModelEx";
DrawModelWires :: (model: Model, position: Vector3, scale: float, tint: Color)  #foreign raylib_native "DrawModelWires";
DrawModelWiresEx :: (model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float, scale: Vector3, tint: Color)  #foreign raylib_native "DrawModelWiresEx";
DrawBoundingBox :: (box: BoundingBox, color: Color)  #foreign raylib_native "DrawBoundingBox";
DrawBillboard :: (camera: Camera, texture: Texture2D, center: Vector3, size: float, tint: Color)  #foreign raylib_native "DrawBillboard";
DrawBillboardRec :: (camera: Camera, texture: Texture2D, sourceRec: Rectangle, center: Vector3, size: float, tint: Color)  #foreign raylib_native "DrawBillboardRec";
CheckCollisionSpheres :: (centerA: Vector3, radiusA: float, centerB: Vector3, radiusB: float) -> bool #foreign raylib_native "CheckCollisionSpheres";
CheckCollisionBoxes :: (box1: BoundingBox, box2: BoundingBox) -> bool #foreign raylib_native "CheckCollisionBoxes";
CheckCollisionBoxSphere :: (box: BoundingBox, center: Vector3, radius: float) -> bool #foreign raylib_native "CheckCollisionBoxSphere";
CheckCollisionRaySphere :: (ray: Ray, center: Vector3, radius: float) -> bool #foreign raylib_native "CheckCollisionRaySphere";
CheckCollisionRaySphereEx :: (ray: Ray, center: Vector3, radius: float, collisionPoint: *Vector3) -> bool #foreign raylib_native "CheckCollisionRaySphereEx";
CheckCollisionRayBox :: (ray: Ray, box: BoundingBox) -> bool #foreign raylib_native "CheckCollisionRayBox";
GetCollisionRayModel :: (ray: Ray, model: Model) -> RayHitInfo #foreign raylib_native "GetCollisionRayModel";
GetCollisionRayTriangle :: (ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayHitInfo #foreign raylib_native "GetCollisionRayTriangle";
GetCollisionRayGround :: (ray: Ray, groundHeight: float) -> RayHitInfo #foreign raylib_native "GetCollisionRayGround";
LoadShader :: (vsFileName: *u8, fsFileName: *u8) -> Shader #foreign raylib_native "LoadShader";
LoadShaderCode :: (vsCode: *u8, fsCode: *u8) -> Shader #foreign raylib_native "LoadShaderCode";
UnloadShader :: (shader: Shader)  #foreign raylib_native "UnloadShader";
GetShaderDefault :: () -> Shader #foreign raylib_native "GetShaderDefault";
GetTextureDefault :: () -> Texture2D #foreign raylib_native "GetTextureDefault";
GetShapesTexture :: () -> Texture2D #foreign raylib_native "GetShapesTexture";
GetShapesTextureRec :: () -> Rectangle #foreign raylib_native "GetShapesTextureRec";
SetShapesTexture :: (texture: Texture2D, source: Rectangle)  #foreign raylib_native "SetShapesTexture";
GetShaderLocation :: (shader: Shader, uniformName: *u8) -> s32 #foreign raylib_native "GetShaderLocation";
SetShaderValue :: (shader: Shader, uniformLoc: s32, value: *void, uniformType: ShaderUniformDataType) #foreign raylib_native "SetShaderValue";
SetShaderValueV :: (shader: Shader, uniformLoc: s32, value: *void, uniformType: ShaderUniformDataType, count: s32) #foreign raylib_native "SetShaderValueV";
SetShaderValueMatrix :: (shader: Shader, uniformLoc: s32, mat: Matrix)  #foreign raylib_native "SetShaderValueMatrix";
SetShaderValueTexture :: (shader: Shader, uniformLoc: s32, texture: Texture2D)  #foreign raylib_native "SetShaderValueTexture";
SetMatrixProjection :: (proj: Matrix)  #foreign raylib_native "SetMatrixProjection";
SetMatrixModelview :: (view: Matrix)  #foreign raylib_native "SetMatrixModelview";
GetMatrixModelview :: () -> Matrix #foreign raylib_native "GetMatrixModelview";
GetMatrixProjection :: () -> Matrix #foreign raylib_native "GetMatrixProjection";
GenTextureCubemap :: (shader: Shader, map: Texture2D, size: s32) -> Texture2D #foreign raylib_native "GenTextureCubemap";
GenTextureIrradiance :: (shader: Shader, cubemap: Texture2D, size: s32) -> Texture2D #foreign raylib_native "GenTextureIrradiance";
GenTexturePrefilter :: (shader: Shader, cubemap: Texture2D, size: s32) -> Texture2D #foreign raylib_native "GenTexturePrefilter";
GenTextureBRDF :: (shader: Shader, size: s32) -> Texture2D #foreign raylib_native "GenTextureBRDF";
BeginShaderMode :: (shader: Shader)  #foreign raylib_native "BeginShaderMode";
EndShaderMode :: ()  #foreign raylib_native "EndShaderMode";
BeginBlendMode :: (mode: s32)  #foreign raylib_native "BeginBlendMode";
EndBlendMode :: ()  #foreign raylib_native "EndBlendMode";
InitVrSimulator :: ()  #foreign raylib_native "InitVrSimulator";
CloseVrSimulator :: ()  #foreign raylib_native "CloseVrSimulator";
UpdateVrTracking :: (camera: *Camera)  #foreign raylib_native "UpdateVrTracking";
SetVrConfiguration :: (info: VrDeviceInfo, distortion: Shader)  #foreign raylib_native "SetVrConfiguration";
IsVrSimulatorReady :: () -> bool #foreign raylib_native "IsVrSimulatorReady";
ToggleVrMode :: ()  #foreign raylib_native "ToggleVrMode";
BeginVrDrawing :: ()  #foreign raylib_native "BeginVrDrawing";
EndVrDrawing :: ()  #foreign raylib_native "EndVrDrawing";
InitAudioDevice :: ()  #foreign raylib_native "InitAudioDevice";
CloseAudioDevice :: ()  #foreign raylib_native "CloseAudioDevice";
IsAudioDeviceReady :: () -> bool #foreign raylib_native "IsAudioDeviceReady";
SetMasterVolume :: (volume: float)  #foreign raylib_native "SetMasterVolume";
LoadWave :: (fileName: *u8) -> Wave #foreign raylib_native "LoadWave";
LoadSound :: (fileName: *u8) -> Sound #foreign raylib_native "LoadSound";
LoadSoundFromWave :: (wave: Wave) -> Sound #foreign raylib_native "LoadSoundFromWave";
UpdateSound :: (sound: Sound, data: *void, samplesCount: s32)  #foreign raylib_native "UpdateSound";
UnloadWave :: (wave: Wave)  #foreign raylib_native "UnloadWave";
UnloadSound :: (sound: Sound)  #foreign raylib_native "UnloadSound";
ExportWave :: (wave: Wave, fileName: *u8)  #foreign raylib_native "ExportWave";
ExportWaveAsCode :: (wave: Wave, fileName: *u8)  #foreign raylib_native "ExportWaveAsCode";
PlaySound :: (sound: Sound)  #foreign raylib_native "PlaySound";
StopSound :: (sound: Sound)  #foreign raylib_native "StopSound";
PauseSound :: (sound: Sound)  #foreign raylib_native "PauseSound";
ResumeSound :: (sound: Sound)  #foreign raylib_native "ResumeSound";
PlaySoundMulti :: (sound: Sound)  #foreign raylib_native "PlaySoundMulti";
StopSoundMulti :: ()  #foreign raylib_native "StopSoundMulti";
GetSoundsPlaying :: () -> s32 #foreign raylib_native "GetSoundsPlaying";
IsSoundPlaying :: (sound: Sound) -> bool #foreign raylib_native "IsSoundPlaying";
SetSoundVolume :: (sound: Sound, volume: float)  #foreign raylib_native "SetSoundVolume";
SetSoundPitch :: (sound: Sound, pitch: float)  #foreign raylib_native "SetSoundPitch";
WaveFormat :: (wave: *Wave, sampleRate: s32, sampleSize: s32, channels: s32)  #foreign raylib_native "WaveFormat";
WaveCopy :: (wave: Wave) -> Wave #foreign raylib_native "WaveCopy";
WaveCrop :: (wave: *Wave, initSample: s32, finalSample: s32)  #foreign raylib_native "WaveCrop";
GetWaveData :: (wave: Wave) -> *float #foreign raylib_native "GetWaveData";
LoadMusicStream :: (fileName: *u8) -> Music #foreign raylib_native "LoadMusicStream";
UnloadMusicStream :: (music: Music)  #foreign raylib_native "UnloadMusicStream";
PlayMusicStream :: (music: Music)  #foreign raylib_native "PlayMusicStream";
UpdateMusicStream :: (music: Music)  #foreign raylib_native "UpdateMusicStream";
StopMusicStream :: (music: Music)  #foreign raylib_native "StopMusicStream";
PauseMusicStream :: (music: Music)  #foreign raylib_native "PauseMusicStream";
ResumeMusicStream :: (music: Music)  #foreign raylib_native "ResumeMusicStream";
IsMusicPlaying :: (music: Music) -> bool #foreign raylib_native "IsMusicPlaying";
SetMusicVolume :: (music: Music, volume: float)  #foreign raylib_native "SetMusicVolume";
SetMusicPitch :: (music: Music, pitch: float)  #foreign raylib_native "SetMusicPitch";
SetMusicLoopCount :: (music: Music, count: s32)  #foreign raylib_native "SetMusicLoopCount";
GetMusicTimeLength :: (music: Music) -> float #foreign raylib_native "GetMusicTimeLength";
GetMusicTimePlayed :: (music: Music) -> float #foreign raylib_native "GetMusicTimePlayed";
InitAudioStream :: (sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream #foreign raylib_native "InitAudioStream";
UpdateAudioStream :: (stream: AudioStream, data: *void, samplesCount: s32)  #foreign raylib_native "UpdateAudioStream";
CloseAudioStream :: (stream: AudioStream)  #foreign raylib_native "CloseAudioStream";
IsAudioStreamProcessed :: (stream: AudioStream) -> bool #foreign raylib_native "IsAudioStreamProcessed";
PlayAudioStream :: (stream: AudioStream)  #foreign raylib_native "PlayAudioStream";
PauseAudioStream :: (stream: AudioStream)  #foreign raylib_native "PauseAudioStream";
ResumeAudioStream :: (stream: AudioStream)  #foreign raylib_native "ResumeAudioStream";
IsAudioStreamPlaying :: (stream: AudioStream) -> bool #foreign raylib_native "IsAudioStreamPlaying";
StopAudioStream :: (stream: AudioStream)  #foreign raylib_native "StopAudioStream";
SetAudioStreamVolume :: (stream: AudioStream, volume: float)  #foreign raylib_native "SetAudioStreamVolume";
SetAudioStreamPitch :: (stream: AudioStream, pitch: float)  #foreign raylib_native "SetAudioStreamPitch";
SetAudioStreamBufferSizeDefault :: (size: s32)  #foreign raylib_native "SetAudioStreamBufferSizeDefault";


make_Rectangle :: (x: $A, y: $B, width: $C, height: $D) -> Rectangle {
    r: Rectangle;
    r.x      = cast(float)x;
    r.y      = cast(float)y;
    r.width  = cast(float)width;
    r.height = cast(float)height;
    return r;
}

make_Color :: (r: $A, g: $B, b: $C, a: $D) -> Color {
    color: Color;
    color.r = cast(u8)r;
    color.g = cast(u8)g;
    color.b = cast(u8)b;
    color.a = cast(u8)a;
    return color;
}

make_Vector3 :: (x: $A, y: $B, z: $C) -> Vector3 {
    v: Vector3;
    v.x = cast(float)x;
    v.y = cast(float)y;
    v.z = cast(float)z;
    return v;
}

make_Vector2 :: (x: $A, y: $B) -> Vector2 {
    v: Vector2;
    v.x = cast(float)x;
    v.y = cast(float)y;
    return v;
}



#scope_file // ---------------

#if OS == .WINDOWS {
    #foreign_system_library "user32";
    #foreign_system_library "gdi32";
    #foreign_system_library "shell32";
    #foreign_system_library "winmm";
    raylib_native :: #foreign_library,no_dll "raylib/lib/raylib";
}
